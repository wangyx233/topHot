#### 二叉树的前、中、后 层次遍历

#### 两数之和，三数之和

- 两数，两次遍历，或者用时间换空间，和转换为差
- 三数，双指针，先排序，然后一次遍历，在遍历里借助两个指针求和，注意重复元素跳过

#### 合并两个有序数组

- 双指针，根据两个数组的长度，从后向前一顿比较赋值
- 或者借助 js 的 api，从前到后比较迭代

PS: 看到`有序` `数组` 双指针，先普通双指针，不行就对撞。没有有序也可以创造条件。

#### 字符串的反转 -> 回文字符串，正反相等

回文：`对称性` `双指针`

string.split('').reverse().join('')

或者两个指针从前向后，简单理解就是前后对称

```
    function isPalindrome(st, ed) {
        while(st<ed) {
            if(s[st] !== s[ed]) {
                return false
            }
            st++
            ed--
        }
        return true
    }

```

#### 正则

#### 链表

1. 有环

借助额外空间 VS 快慢指针

- 时间，空间都是 O(n) 能跳出循环就是没环，否则则是有环，给个标志跳出循环就可以呀。
- 快慢指针，如果没环，快的肯定就先到头了。有过有环那，快慢会相遇。注意判断 next

判断环的位置

#### 栈

和括号有关，可能和栈有关

#### 回溯方法

- 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。

> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 ——LeetCode

配合递归，以及 DFS 的思想操作起来。

- 什么时候用？

1. 题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。
2. 题目经分析后，可以转化为树形逻辑模型求解。

- 怎么用？

1. 树形逻辑模型；
2. 递归式和递归边界。

> 关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。

```
function xxx(入参) {
  前期的变量定义、缓存等准备工作

  // 定义路径栈
  const path = []

  // 进入 dfs
  dfs(起点)

  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return
    }

    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```
